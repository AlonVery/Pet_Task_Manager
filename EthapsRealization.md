## **Этап 1: Базовый HTTP-сервер + in-memory реализация**
Минимальная жизнеспособная версия приложения.
**Цели:**
- Поднять embedded-Jetty.
- Реализовать простой собственный роутер (маршрутизатор).
- Создать 2–3 REST-эндпоинта (например: `/boards`, `/tasks`).
- Хранить данные в памяти — через `Map` или `ConcurrentHashMap`.
- Описать базовые domain-модели (Board, Task, User).
- Реализовать примитивные use-cases (создать доску, создать задачу)
  **Задача этапа:** понять фундамент — HTTP, роутинг, обработка запросов/ответов, чистые доменные модели.

---

## **Этап 2: Разделение слоёв и доменная архитектура**

Перевод структуры проекта к нормальной архитектуре.

**Цели:**

- Разделить код на слои:

    - **domain** — сущности, value objects, доменные сервисы,

    - **application** — use cases / сервисы приложения,

    - **web** — контроллеры, парсеры запросов, JSON-ответы,

    - **infrastructure** — Jetty, репозитории, клиенты.

- Ввести **интерфейсы репозиториев** в domain/application.

- Перевести контроллеры на работу через use-cases.

- Минимизировать зависимость домена от внешних технологий.


**Задача этапа:** добиться чистой архитектурной структуры и осознанных зависимостей.

---

## **Этап 3: Подключение PostgreSQL**

Сделать переход от памяти к реальной базе.

**Цели:**

- Настроить подключение к PostgreSQL через чистый JDBC.

- Реализовать JDBC-репозитории:

    - `BoardRepositoryJdbc`,

    - `TaskRepositoryJdbc`,

    - `UserRepositoryJdbc`.

- Перенести хранение данных из in-memory Map в таблицы.

- Реализовать мапперы (row-mapping) между ResultSet и доменными моделями.

- Добавить миграции SQL (можно вручную или через простой мигратор).


**Задача этапа:** научиться работать с БД без ORM и правильно выстраивать слой инфраструктуры.

---

## **Этап 4: Подключение Redis**

Добавление кэша и простой авторизации.

**Цели:**

- Поднять Redis и подключить клиент (Jedis или Redisson).

- Реализовать хранение токенов сессий/авторизаций в Redis.

- Добавить простую токен-based авторизацию.

- Ввести кэширование досок/задач:

    - кэш по ключу `board:{id}`,

    - кэш-инвалидация при обновлении.


**Задача этапа:** понять работу кэша и научиться работать со stateful-данными вне БД.

---

## **Этап 5: Kafka и доменные события**

Добавление событийной архитектуры.

**Цели:**

- Определить доменные события (например: `TaskCreated`, `TaskMoved`, `TaskCompleted`).

- Генерировать события в use-cases при изменении сущностей.

- Настроить Kafka-producer для публикации событий.

- Написать Kafka-consumer, который:

    - пишет логи активности,

    - формирует audit trail,

    - может обновлять аналитические проекции (если захочешь).


**Задача этапа:** освоить событийное взаимодействие без фреймворков и интеграцию с брокером сообщений.

---

## **Этап 6: Шлифовка архитектуры и паттернов**

Финальная доводка проекта.

**Цели:**

- Пройтись по SOLID и убедиться, что:

    - у классов одна ответственность,

    - зависимости направлены внутрь,

    - интерфейсы минимальны,

    - инфраструктура не протекает в домен.

- Ввести и оформить паттерны:

    - **Factories** — создание доменных сущностей,

    - **Facades** — упрощение сложных операций,

    - **Adapters** — привязка инфраструктуры к домену,

    - **Template Method / Strategy** — где повторяется логика.

- Навести порядок в:

    - пакетах,

    - зависимостях,

    - именовании,

    - слоях.

- Написать минимальные тесты (юнит + интеграционные).


**Задача этапа:** сделать проект профессиональным и архитектурно целостным.